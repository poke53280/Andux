<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.beanshell.org/manual/printable.html -->
<HTML><HEAD><TITLE>BeanShell User's Manual</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<H1>BeanShell User's Manual</TITLE></H1>
<H1>Table of Contents</H1><FONT size=+1>
<UL>
  <LI><A href="http://www.beanshell.org/manual/quickstart.html">Quick Start</A> 
  <LI><A href="http://www.beanshell.org/manual/syntax.html">BeanShell Syntax</A> 

  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/syntax.html#Standard_Java_Syntax">Standard 
    Java Syntax</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/syntax.html#Loose_Java_Syntax">Loose 
    Java Syntax</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/syntax.html#Convenience_Syntax">Convenience 
    Syntax</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/syntax.html#Importing_classes_and_packages">Importing 
    classes and packages</A></LI></UL>
  <LI><A href="http://www.beanshell.org/manual/methods.html">Methods</A> 
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/methods.html#Scope_modifiers:_this,_super,_global">Scope 
    modifiers: this, super, global</A></LI></UL>
  <LI><A href="http://www.beanshell.org/manual/objects.html">Scripted 
  Objects</A> 
  <LI><A href="http://www.beanshell.org/manual/events.html">Scripted Event 
  Handling</A> 
  <LI><A href="http://www.beanshell.org/manual/threads.html">Scripting 
  Threads</A> 
  <LI><A href="http://www.beanshell.org/manual/specialvarsvalues.html">Special 
  Variables and Values</A> 
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/specialvarsvalues.html#Undefined_variables">Undefined 
    variables</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/specialvarsvalues.html#Special_features_of_'This'_type_references">Special 
    features of 'This' type references</A></LI></UL>
  <LI><A href="http://www.beanshell.org/manual/classpath.html">Class Path 
  Management</A> 
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/classpath.html#Changing_the_Class_Path">Changing 
    the Class Path</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/classpath.html#Auto-Importing_from_the_Classpath">Auto-Importing 
    from the Classpath</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/classpath.html#Reloading_Classes">Reloading 
    Classes</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/classpath.html#Class_Loading_in_Java">Class 
    Loading in Java</A></LI></UL>
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/classpath.html#Class_Loading_in_BeanShell">Class 
    Loading in BeanShell</A></LI></UL>
  <LI><A href="http://www.beanshell.org/manual/desktop.html">BeanShell 
  Desktop</A> 
  <LI><A href="http://www.beanshell.org/manual/embedding.html">Using BeanShell 
  in Your Application</A> 
  <LI><A href="http://www.beanshell.org/manual/servermode.html">Server Mode</A> 
  <LI><A href="http://www.beanshell.org/manual/execscripts.html">Executable 
  scripts under Unix</A> 
  <LI><A href="http://www.beanshell.org/manual/bshpackage.html">The bsh 
  Package</A> 
  <UL>
    <LI><A 
    href="http://www.beanshell.org/manual/bshpackage.html#Adding_Commands_to_BeanShell">Adding 
    Commands to BeanShell</A></LI></UL>
  <LI><A href="http://www.beanshell.org/manual/more.html">Learning More...</A> 
  <LI><A href="http://www.beanshell.org/manual/credit.html">Credit and 
  Acknowledgments</A> </LI></UL></FONT>
<HR>

<H1>Quick Start</H1>This is just the crash course to get you going. I'm leaving 
out some important options and details. Please see the user's guide (which is 
not very long in its entirety) for all of the details. 
<P>
<H4>Download and Run BeanShell </H4>Download the <A 
href="http://www.beanshell.org/download.html">latest jar file</A> and start up 
BeanShell either in the graphical desktop mode or on the command line. 
<P>If you just want to start playing around you may be able to to launch the 
BeanShell desktop by simply double clicking on the bsh JAR file. More generally 
however you'll want to add the jar to your classpath so that you can work with 
your own classes and applications easily. 
<P>
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>
<EM>unix:</EM>     export CLASSPATH=$CLASSPATH:bsh-xx.jar
<EM>windows:</EM>  set classpath %classpath%;bsh-xx.jar

    java bsh.Console       // run the graphical desktop
or
    java bsh.Interpreter   // run as text-only on the command line
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P><EM>Note: If you are running under JDK 1.1 and want to use the GUI you'll 
also have to add the swing JAR file to your classpath.</EM> 
<P>Once BeanShell is running you can also add to the classpath using the 
addClassPath() command. 
<P>The above examples show how to run bsh interactively. It's also possible to 
run bsh in a <A href="http://www.beanshell.org/manual/servermode.html">server 
mode</A> and to <A href="http://www.beanshell.org/manual/embedding.html">embed 
bsh</A> for non-interactive use in your applications. You can even make <A 
href="http://www.beanshell.org/manual/execscripts.html">executable bsh 
scripts</A> under Unix using the standard "#!" syntax. See the <A 
href="http://www.beanshell.org/manual/contents.html">user's manual</A> for more 
information on those topics. 
<P>
<H4>The BeanShell Desktop and Console Windows </H4>Upon starting BeanShell one 
console window will open. By right clicking on the <A 
href="http://www.beanshell.org/manual/desktop.html">desktop</A> background can 
also open additional console windows or other tools such as the BeanShell class 
browser. 
<P>Each console window effectively runs a separate bsh interpreter. Within the 
graphical console you have basic command history, line editing, and cut and 
paste. From any console window you can open a simple editor window for that 
console. In it you can write scripts and hit the 'eval' button to evaluate them 
in the attached workspace. 
<P>
<H4>Java Statements and Expressions </H4>At the prompt you can type standard 
Java statements and expressions. Statements and expressions are all of the 
normal things that you'd say inside a Java method: e.g. variable declarations 
and assignments, method calls, loops, conditionals, etc. 
<P>You can use these exactly as they would appear in Java, however in BeanShell 
you have the option of working with "loosely typed" variables. That is, you can 
simply be lazy and not declare the types of variables that you use (both 
primitives and objects). BeanShell will still give you an error if you attempt 
to misuse the actual type of the variable. 
<P>Here are some examples: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo = "Foo";    
    four = (2 + 2)*2/2;
    print( foo + " = " + four );   // print() is a bsh command
    
    // Do a loop
    for (i=0; i&lt;5; i++)
        print(i);   

    // Pop up a frame with a button in it
    b = new JButton("My Button");
    f = new JFrame("My Frame");
    f.getContentPane().add(b, "Center");
    f.pack();
    f.show();
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<H4>Useful BeanShell Commands </H4>In the previous example we used a convenient 
"built-in" <A href="http://www.beanshell.org/manual/bshcommands.html">BeanShell 
command</A> called <A 
href="http://www.beanshell.org/manual/bshcommands.html#print">print()</A>, to 
display values. <A 
href="http://www.beanshell.org/manual/bshcommands.html#print">print()</A> does 
pretty much the same thing as System.out.println() except that it insures that 
the ouput always goes to the command line. <A 
href="http://www.beanshell.org/manual/bshcommands.html#print">print()</A> also 
displays some types of objects (such as arrays) more verbosely than Java would. 
Another very useful command is <A 
href="http://www.beanshell.org/manual/bshcommands.html#show">show()</A>, which 
toggles on and off automatic <A 
href="http://www.beanshell.org/manual/bshcommands.html#print">print()</A>ing of 
the result of every line you type. 
<P>Here are a few other examples of <A 
href="http://www.beanshell.org/manual/bshcommands.html">BeanShell commands</A>: 
<UL>
  <LI><A 
  href="http://www.beanshell.org/manual/bshcommands.html#source">source()</A>, 
  <A href="http://www.beanshell.org/manual/bshcommands.html#run">run()</A> - 
  read a bsh script into this interpreter, or run it in a new interpreter 
  <LI><A 
  href="http://www.beanshell.org/manual/bshcommands.html#frame">frame()</A> - 
  display the AWT/JFC component in a Frame 
  <LI><A 
  href="http://www.beanshell.org/manual/bshcommands.html#load">load()</A>, <A 
  href="http://www.beanshell.org/manual/bshcommands.html#save">save()</A> - load 
  or save serializable objects 
  <LI><A href="http://www.beanshell.org/manual/bshcommands.html#cd">cd()</A>, <A 
  href="http://www.beanshell.org/manual/bshcommands.html#cat">cat()</A>, <A 
  href="http://www.beanshell.org/manual/bshcommands.html#dir">dir()</A>, pwd(), 
  etc. - Unix-like shell commands 
  <LI><A href="http://www.beanshell.org/manual/bshcommands.html#exec">exec()</A> 
  - run a native application </LI></UL>
<P>See the complete list of <A 
href="http://www.beanshell.org/manual/bshcommands.html">BeanShell commands</A> 
for more information. 
<P><A href="http://www.beanshell.org/manual/bshcommands.html">BeanShell 
commands</A> are simply methods which are implemented by bsh scripts supplied in 
the bsh jar file. You can, of course, define your own methods in bsh and also 
add your own scripts to the classpath to extend the basic command set. 
<P>
<H4>Scripted Methods </H4>You can declare and use methods in bsh just as you 
would in a Java class. 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    int addTwoNumbers( int a, int b ) {
        return a + b;
    }

    sum = addTwoNumbers( 5, 7 );  // 12
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>Bsh methods may also have dynamic (loose) argument and return types. 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    add( a, b ) {
        return a + b;
    }

    foo = add(1, 2);            // 3
    foo = add("Oh", " baby");   // "Oh baby"
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<H4>Scripted Objects </H4>In BeanShell, as in JavaScript and Perl, method 
"closures" allow you to create scripted objects. You can turn the results of a 
method call into an object reference by having the method return the special 
value <STRONG>this</STRONG>. You can then use that reference to refer to any 
variables set in the method call. To make useful objects you need instance 
methods of course so in BeanShell methods may also contain methods at any level. 

<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo() {
        print("foo");
        x=5;

        bar() {
            print("bar");
        }

        return this;
    }

    myfoo = foo();    // prints "foo"
    print( myfoo.x ); // prints "5"
    myfoo.bar();      // prints "bar"
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>If this seems strange to you please see the <A 
href="http://www.beanshell.org/manual/contents.html">user's manual</A> for more 
details. 
<P>BeanShell Syntax bshcommands.html methods.html </PAGE>BeanShell is primarily 
a Java interpreter, so you probably already know most of what you need to start 
using and scripting in bsh. This section will describe specifically what portion 
of the Java langauge bsh interprets and how bsh extends it - loosens it up - to 
be more scripting language like. 
<P><!-- heading --><A name=Standard_Java_Syntax>
<H2>Standard Java Syntax</H2></A>At the prompt you can type normal Java 
statements and expressions and display the results. Statements and expressions 
are the kinds of things you normally find inside of a Java method - variable 
assignments, method calls, math expressions, for-loops, etc., etc. 
<P>Here are some examples: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    // Use a hashtable
    Hashtable h = new Hashtable();
    Date d = new Date();
    h.put("today", d);

    // Print the current clock value
    print( System.currentTimeMillis() );

    // Loop
    for (int i=0; i&lt;5; i++)
        print(i);

    // Pop up an AWT frame with a button in it
    JButton b = new JButton("My Button");
    JFrame f = new JFrame("My Frame");
    f.getContentPane()add(b, "Center");
    f.pack();
    f.show();
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P><!-- heading --><A name=Loose_Java_Syntax>
<H2>Loose Java Syntax</H2></A>In the examples above, all of our variables have 
declared types - e.g. 'JButton b'. Beanshell will enforce these types, as you 
will see if you later try to assign something other than a JButton to the 
variable 'b' (you will get an error message). However bsh also supports 
dynamically typed variables - that is, you can refer to variables without 
declaring them first and without specifying any type. In this case bsh will do 
type checking where appropriate at "runtime". So, for example, we could have 
left off the types in the above example and simply said something like: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo = new JButton("Another Button");
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>We are then free to assign 'foo' to another type of Java object later. 
Untyped bsh variables can also freely hold Java primitive values like int and 
boolean. Don't worry, bsh always knows the real types and only lets you use the 
values where appropriate. For primitive types this includes doing the correct 
numeric promotion that the real Java language would do when you use them in an 
expression. 
<P>There is currently no formal language specification. There is one <A 
href="http://www.beanshell.org/manual/NoteOnForScoping.html">note on for loop 
scoping</A> 
<P><!-- heading --><A name=Convenience_Syntax>
<H2>Convenience Syntax</H2></A>
<P>In bsh you may access JavaBean properties as if they were fields: <PRE>    b = new java.awt.Button();
    b.label = "my button";  // Equivalent to: b.setLabel("my button");
</PRE>Of course if there is a field of the same name (e.g. label in the above 
example) then it would take precedence. 
<P>If you wish to avoid ambiguity Bsh provides an additional, uniform syntax for 
accessing Java Bean properties and Hashtable entries. You may use the "{}" curly 
brace construct with a String identifier as a qualifier on any variable of the 
appropriate type: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    b = new java.awt.Button();
    b{"label"} = "my button";  // Equivalent to: b.setLabel("my button");

    h = new Hashtable();
    h{"foo"} = "bar";          // Equivalent to: h.put("foo", "bar");
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P><!-- heading --><A name=Importing_classes_and_packages>
<H2>Importing classes and packages</H2></A>In BeanShell as in Java, you can 
either refer to classes by their fully qualified names, or you can 
<STRONG>import</STRONG> one or more classes from a Java package. 
<P>
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    import mypackage.MyClass;
or
    import mypackage.*;
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>You may also automatically import the entire classpath using: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    import *;
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>See <A href="http://www.beanshell.org/manual/classpath.html">Class Path 
Management</A> for details. 
<P>By default, several Java core and extension packages are imported for you. 
They are: 
<UL>
  <LI>java.lang 
  <LI>java.awt 
  <LI>java.awt.event 
  <LI>javax.swing 
  <LI>javax.swing.event 
  <LI>java.util 
  <LI>java.io 
  <LI>java.net </LI></UL>
<P>
<HR>

<H1>Methods</H1>You can define define methods in bsh, just as they would appear 
in Java: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    int addTwoNumbers( int a, int b ) {
        return a + b;
    }
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>and use them immediately as you would any <A 
href="http://www.beanshell.org/manual/bshcommands.html">bsh command</A>: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    sum = addTwoNumbers( 5, 7 );
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>Just as bsh variables may be dynamically typed, bsh methods may have dynamic 
argument and return types. We could, for example, have declared our method like 
so: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    add( a, b ) {
        return a + b;
    }
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>In this case, bsh would dynamically determine the types when the method is 
called and "do the right thing": 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo = add(1, 2);
    print( foo ); // 3

    foo = add("Oh", " baby");
    print( foo ); // Oh baby
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>In the first case Java performed arithmetic addition on the integers 1 and 2. 
By the way, if we had passed in numbers of other types bsh would have performed 
the appropriate numeric promotion and returned the right type. In the second 
case bsh performed the usual string concatenation for String types and returned 
a String object. 
<P>Methods with unspecified return types may return any type of object (as in 
the previous example). Alternatively they may also simply issue a "return;" 
without a value, in which case the effective type of the method is "void" (no 
type). In either case, the return statement is optional. If the method does not 
perform an explicit "return" statement, the value of the last statement or 
expression in the method body becomes the return value (and must adhere to any 
declared return typing). 
<P>
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="70%">
  <TBODY>
  <TR>
    <TD bgColor=#eeeebb><STRONG>Note:</STRONG> <BR><BR>The namespaces for 
      methods and variables are separate, so it is ok to have a method named 
      "foo()" and variable named "foo" within the same scope. 
</TD></TR></TBODY></TABLE></CENTER>
<P>
<P><!-- heading --><A name=Scope_modifiers:_this,_super,_global>
<H2>Scope modifiers: this, super, global</H2></A>
<P>Within a method, it is possible to explicitly qualify a variable or method 
reference with the values 'this', 'super', and 'global' to refer to, 
respectively, the current scope, the calling method's scope, or the global 
scope. 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    a = 42;
    foo() {
        a = 97;
        print( a );
        print( this.a );
        print( super.a );
    }

    foo();  // prints 97, 97, 42
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>In the case above, 'global' and 'super' both refer to the top level scope. 
<P>We'll refer to instances of the special 'this', 'super', and 'global' 
references as "This" type references. 
<P>
<HR>

<H1>Scripted Objects</H1>In bsh you can script objects as "method closures", 
similar to those in Perl5.0 and JavaScript. 
<P>As in most languages, executing bsh methods have their own "local" scope that 
holds argument variables and locally declared variables. For example, any 
variables that we might have declared within our add() method above would 
normally only be visible within the scope of and for the lifetime of a 
particular method invocation: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo() {
        bar = 42;
        print( bar );
    }   

    foo();  // prints 42
    print( bar ); // Error, var is undefined here 
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>However, in BeanShell you can "hang on" to this scope after exiting the 
method by returning the special value: "this". As in Java, "this" refers to the 
current object context. By saving the "this" reference, you can continue to 
refer to variables defined within the method, using the standard Java "." 
notation: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo() {
        bar = 42;
        return this;
    }

    obj = foo();
    print( obj.bar ); // 42
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>In the above, the value returned by the foo() method is effectively an 
instance of a "foo" object. In this case foo is really just acting like a 
structure, but bsh methods are also allowed to contain their own methods: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo() {
        bar() {
            ...
        }
    }
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>Method may define any number of local methods in this way, to an arbitrary 
depth. 
<P>Statements and expressions within a Bsh method can call their own "local" 
methods just like any other method. (Locally declared methods shadow outer-more 
methods like local variables shadow outer variables.) And we can invoke local 
methods of objects through an appropriate 'this' reference for that object: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo() {
        int a = 42;
        bar() {
            print("The bar is open!");
        }
        
        bar();
        return this;
    }

    obj = foo();     // prints "the bar is open!"
    print ( obj.a )  // 42
    obj.bar();       // prints "the bar is open!"
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>Within a nested method, locally declared variables at each level of scope 
shadow methods of the same name in outer-more scopes. Otherwise, variables are 
visible to an arbitrary depth of scope. 
<P>
<HR>

<H1>Scripted Event Handling</H1>One of the most powerful features of Bsh is the 
ability to handle events from AWT objects in Bsh scripts. To do this simply 
define the appropriately named method from the java.awt.event listener interface 
and registering the corresponding 'This' type reference with the event source. 
For example, we could get the events from a button like so: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    button = new java.awt.Button("foo!");

    actionPerformed( event ) {
        print( event );
    }

    button.addActionListener( this );
    frame( button );  // show it
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>Now when ActionEvents are fired by the button, your actionPerformed() method 
will be invoked. The bsh 'this' reference effectively implements all of the core 
AWT event listener interface types and directs them to the appropriately named 
method, if it exists. 
<P>Remember that you don't have to define all of your event handlers globally. 
You can handle events in any bsh object scope. For example, the following method 
creates a button that displays a message when pushed: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    messageButton( message ) {
        b = new Button("Press Me");
        b.addActionListener( this );
        frame(b);
     
        actionPerformed( e ) {
            print( message );
        }
    }

    messageButton("Hey you!");
    messageButton("Another message...");
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>The above will create two buttons and each will display its own message when 
pushed. Each has a separate instance of the event handler object. Note too that 
we could return a 'this' reference from the handler method and use it in other 
contexts to register listeners... 
<P>See also <A href="http://www.beanshell.org/manual/examples/dragtext.html">the 
dragText example</A>. 
<P><EM>What kind of events can bsh handle in this way?</EM> 
<P>When running under JDK1.3 or greater BeanShell can handle any kind of event 
(serve as any kind of event listener) because bsh scripts are capable of 
implementing arbitrary Java interfaces. However when running under JDK1.2 (or 
JDK1.1 + Swing) only the core AWT and Swing interfaces are available. In the 
pre-JDK1.3 case the bsh.This object implements these interfaces (along with 
Runnable, etc.) directly. 
<P>
<H1>Scripting Threads</H1>BeanShell 'This' type references also implement the 
standard java.lang.Runnable interface, so you can declare a "<A 
href="http://www.beanshell.org/manual/bshcommands.html#run">run()</A>" method in 
your bsh objects and make it the target of a Thread. 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    foo() {
        run() {
            // do work...
        }
        return this;
    }
    
    foo = foo();
    new Thread( foo ).start();
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>You can also use the bg() command to run an external script in a separate 
thread. example... FINISH 
<P>
<HR>

<H1>Special Variables and Values</H1>See also <A 
href="http://www.beanshell.org/manual/printable.html#this">BOGUSLINKthis, super, 
and global</A>. 
<P><EM>Special variables</EM> 
<P>
<UL>
  <LI><STRONG><ANY>$_</STRONG> - the value of the last expression evaluated. 
  <LI><STRONG>bsh.Console bsh.console</STRONG> - The primary console, if one 
  exists. 
  <LI><STRONG>java.awt.AppletContext bsh.appletcontext</STRONG> - the applet 
  context, if one exists. 
  <LI><STRONG>String bsh.cwd</STRONG> - used by the <A 
  href="http://www.beanshell.org/manual/bshcommands.html#cd">cd()</A> and <A 
  href="http://www.beanshell.org/manual/bshcommands.html#dir">dir()</A> 
  commands. 
  <LI><STRONG>boolean bsh.show</STRONG> - used by the <A 
  href="http://www.beanshell.org/manual/bshcommands.html#show">show()</A> 
  command. 
  <LI><STRONG>boolean bsh.interactive</STRONG> - is this interpreter running in 
  an interactive mode or sourceing a file? 
  <LI><STRONG>boolean bsh.evalOnly</STRONG> - Does this interpreter have an 
  input stream or is it only serving as a bag for eval() operations. </LI></UL>
<P><!-- heading --><A name=Undefined_variables>
<H2>Undefined variables</H2></A>
<P>You can test to see if a variable is "undefined" with the value "void", e.g.: 

<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    if ( foobar == void )
        // undefined
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>You can return a defined variable to the undefined state using the unset() 
command: 
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    a == void;  // true
    a=5;
    unset("a"); // note the quotes
    a == void;  // true
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P><!-- heading --><A name="Special_features_of_'This'_type_references">
<H2>Special features of 'This' type references</H2></A>
<P>'This' type references have four special "magic" members: 
<UL>
  <LI>".interpreter" is always a reference to the currently executing Bsh 
  Interpreter object. 
  <LI>".namespace" is always a reference to the Bsh NameSpace object of the 
  current context. 
  <LI>".variables" is a String [] listing the variables defined in this 
  namespace. 
  <LI>".methods" is a String [] listing the methods defined in this namespace. 
  </LI></UL>
<P>These are mainly for internal use by <A 
href="http://www.beanshell.org/manual/bshcommands.html">bsh commands</A>. Note 
that there are certain special situations in which the ".interpreter" reference 
may not be available, such as in AWT event handlers (see the next section). 
<P>
<HR>

<H1>Class Path Management</H1>BeanShell is capable of some very fine grained and 
sophisticated class reloading and modifications to the class path. BeanShell can 
even map the entire class path to allow for automatic importing of classes. <!-- heading --><A name=Changing_the_Class_Path>
<H2>Changing the Class Path</H2></A><STRONG>addClassPath( URL | path )</STRONG> 
<P>Add the specified directory or archive to the classpath. Archives may be 
located by URL, allowing them to be loaded over the network. 
<P>Examples: 
<P><PRE>    addClassPath( "/home/pat/java/classes" );
    addClassPath( "/home/pat/java/mystuff.jar" );
    addClassPath( new URL("http://myserver/~pat/somebeans.jar") );
</PRE>Note that if you add class path that overlaps with the existing Java user 
classpath then the new path will effectively reload the classes in that area. 
<P><STRONG>setClassPath( URL [] )</STRONG> 
<P>Change the entire classpath to the specified array of directories and/or 
archives. 
<P>This command has some important side effects. It effectively causes all 
classes to be reloaded (including any in the Java user class path at startup). 
Please see "Class Reloading" below for further details. 
<P>Note: setClassPath() cannot currently be used to make the classpath smaller 
than the Java user path at startup. 
<P><!-- heading --><A name=Auto-Importing_from_the_Classpath>
<H2>Auto-Importing from the Classpath</H2></A>As an alternative to explicitly 
importing class names you may use the following statement to trigger automatic 
importing: <PRE>    <STRONG>import *;</STRONG>
</PRE>There may be a significant delay while the class path is mapped. This is 
why auto-importing is not turned on by default. When run interactively, Bsh will 
report the areas that it is mapping. 
<P>It is only necessary to issue the auto-import command once. Thereafter 
changes in the classpath via the addClassPath() and setClassPath() commands will 
remap as necessary. 
<P><EM>Note: As of BeanShell 1.1alpha new class files added to the classpath 
(from outside of BeanShell) after mapping will not be seen in imports. </EM><!-- heading --><A name=Reloading_Classes>
<H2>Reloading Classes</H2></A>BeanShell provides an easy to use mechanism for 
reloading classes from the classpath. It is possible in BeanShell to reload 
arbitary subsets of classes down to a single class file. However There are 
subtle issues to be understood with respect to what it means to reload a class 
in the Java environment. Please see the discussion of class loading detail 
below. But in a nutshell, it is important that classes which work together be 
reloaded together at the same time, unless you know what you are doing. 
<P><STRONG>reloadClasses( [ package name ] )</STRONG> 
<P>The most course level of class reloading is accomplished by issuing the 
reloadClasses() command with no arguments. <PRE>    reloadClasses();
</PRE>This will effectively reload all classes in the current classpath 
(including any changes you have made through addClassPath()). 
<P><EM>Note: that reloading the full path is actually a light weight operation 
that simply replaces the class loader - normal style class loading is done as 
classes are subsequently referenced. </EM>
<P>Be aware that any object instances which you have previously created may not 
function with new objects created by the new class loader. Please see the 
discussion of class loading details below. 
<P>You can also reload all of the classes in a specified package: <PRE>    reloadClasses("mypackage.*");
</PRE>This will reload only the classes in the specified package. The classes 
will be reloaded even if they are located in different places in the claspath 
(e.g. if you have some of the package in one directory and some in another). 
<P>As a special case for reloading unapckaged classes the following commands are 
equivalent: <PRE>    reloadClasses(".*") 
    reloadClasses("<UNPACKAGED>")
</PRE>
<P>You can also reload just an individual class file: <PRE>    reloadClasses("mypackage.MyClass") 
</PRE><EM>Note: As of alpha1.1 classes contained in archives (jar files) cannot 
be reloaded. i.e. jar files cannot be swapped.</EM> 
<P>
<H4>Mapping the path</H4>Unlike the reloadClases() command which reloads the 
entire class path, when you issue a command to reload a package or individual 
class name BeanShell must map some portions of the classpath to find the 
location of those class files. This operation can be time consuming, but it is 
only done once. If running in interactive mode feedback will be given on the 
progress of the mapping. 
<P><!-- heading --><A name=Class_Loading_in_Java>
<H2>Class Loading in Java</H2></A>A fundamental Java security propsition is that 
classes may only be loaded through a class loader once and that classes loaded 
through different class loaders live in different name spaces. By different name 
spaces I mean that they are not considered to be of the same type, even if they 
came from the very same class file. 
<P>You can think of this in the following way: When you load classes through a 
new class loader imagine that every class name is prefixed with the identifier 
"FromClassLoaderXXX" and that all internal references to other classes loaded 
through that class loader are similarly rewritten. Now if you attempt to pass a 
reference to a class instance loaded through another class loader to one of your 
newly loaded objects, it will not recognize it as the same type of class. 
<P>BeanShell works with objects dynamically through the reflection API, so your 
scripts will not have a problem recognizing reloaded class objects. However any 
objects which have you already created might not like them. <EM>More, 
etc...</EM> <!-- heading --><A name=Class_Loading_in_BeanShell>
<H2>Class Loading in BeanShell</H2></A>The following is a discussion of the 
BeanShell class loader architecture, which allows both course class path 
extension and fine grained individual class reloading... 
<P><STRONG>Thriftiness</STRONG> - Abiding by the BeanShell thriftiness 
proposition: no class loading code is exercised unless directed by a command. 
BeanShell begins with no class loader and only adds class loading in layers as 
necessay to achieve desired effects. 
<P>The following diagram illustrates the two layer class loading scheme: 
<P>
<CENTER><IMG src="BeanShell User's Manual-filer/bshclassloading.gif"> </CENTER>
<P>A "base" class loader is used to handle course changes to the classpath 
including added path. Unless directed by setClassPath() the base loader will 
only add path and will not cover existing Java user class path. This prevents 
unecessary class space changes for the existing classes. 
<P>Packages of classes and individual classes are mapped in sets by class 
loaders capable of handling discrete files. A mapping of reloaded classes is 
maintained. The discrete file class loaders will also use this mapping to 
resolve names outside there space, so when any individual class is reloaded it 
will see all previously reloaded classes as well. 
<P>The BshClassManager knows about all class loader changes and broadcasts 
notification of changes to registered listeners. BeanShell namespaces use this 
mechanism to dereference cached type information, however they do not remove 
existing object instances. 
<P>Type caching is extremely important to BeanShell performance. So changing the 
classloader, which necessitates clearing all type caches, should be considered 
an expensive operation. 
<P>
<HR>

<H1>BeanShell Desktop</H1><IMG src="BeanShell User's Manual-filer/splash1.jpeg"> 

<P>The BeanShell Desktop is a simple GUI environment that provides multiple bsh 
shell windows (MDI), a simple text editor, and a simple class browser. The 
desktop is mostly implemented by bsh scripts. 
<P>
<H3>Shell Windows</H3><IMG 
src="BeanShell User's Manual-filer/colorconsole.jpeg"> 
<P>The <A href="http://www.beanshell.org/manual/console.html">bsh console 
window</A>s provide simple command line editing, history, cut &amp; paste, and 
variable and class name completion. 
<P>
<H3>Editor Windows</H3><IMG 
src="BeanShell User's Manual-filer/editorwindow.gif"> 
<P>
<H3>The Class Browser</H3><IMG 
src="BeanShell User's Manual-filer/bshclassbrowser.gif"> 
<P>
<H1>Using BeanShell in Your Application</H1>
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>    import bsh.Interpreter;
    ...

    Interpreter i = new Interpreter();
    i.setVariable("foo", 5);
    i.eval("bar = foo*10");
    System.out.println("bar = "+i.getVariable("bar") );
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>Note: The trailing ";" semi-colon in the string containing the bsh statement 
to be evaluated is optional in this mode (bsh simply always adds one). 
<P><EM>Embedding in Server Mode is the same, coming...</EM><BR><EM>More 
coming...</EM> 
<P>
<H1>Server Mode</H1>
<H3></EM>Note: this document is out of date. Check back soon for an update with 
1.0beta</EM></H3>
<P>Server mode lets you access a bsh session inside of a remote VM. You can 
literally telnet into the application and type commands at the bsh shell prompt. 
Or even better you can use your a web browser to bring up a remote console. 
<P>After starting the bsh server you can connect your web browser to the 
specified port. Bsh will act as an httpd and send over a remote console applet. 
You will get a bsh session that looks like the regular console applet, but it 
will be running remotely in the originating VM. You can open as many sessions 
into that VM as you like in this way... 
<P>Special Notes: In <A 
href="http://www.beanshell.org/manual/servermode.html">server mode</A> bsh 
actually runs *two* services: a (minimal) httpd at the port you specify and a 
session server at your port + 1. You can actually connect to the session server 
with telnet, if you want to try it out...(you have to type ";"s manually at the 
end of every line). 
<P><EM>More coming...</EM> 
<P>
<HR>

<H1>Executable scripts under Unix</H1>
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>#!/usr/java/bin/java bsh.Interpreter 

print("foo");
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<P>
<CENTER>
<TABLE border=1 cellPadding=5 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#cfcfcc><PRE>#!/bin/sh
#! The following hack allows java to reside anywhere in the classpath.
//bin/sh -c "exec java bsh.Interpreter $0" ${1+"@"}; exit

print("foo");
</PRE></TD></TR></TBODY></TABLE></CENTER>
<P>
<H1>The bsh Package</H1><!-- heading --><A name=Adding_Commands_to_BeanShell>
<H2>Adding Commands to BeanShell</H2></A>
<P>Adding to the set of "prefab" commands supplied with bsh can be about as easy 
as writing any other bsh methods. You simply have to place your bsh scripts in a 
bsh/commands/ directory in the classpath (or inside the JAR file). <P. 
href="../manual/bshcommands.html" <a implement also can You>bsh commands</A> 
directly in Java as .class files which are dynamically loaded when needed. The 
<A href="http://www.beanshell.org/manual/bshcommands.html#dir">dir()</A> 
commands are an example of a <A 
href="http://www.beanshell.org/manual/bshcommands.html">bsh command</A> that is 
implemented in Java. (I did this originaly for speed). 
<P><EM>More info coming</EM> 
<P>
<HR>

<H1>Learning More...</H1>
<HR>
<A name=more>
<H4>Learning More...</H4></A>Almost all of the built-in <A 
href="http://www.beanshell.org/manual/bshcommands.html">bsh commands</A> are 
simply bsh scripts stored in the bsh jar file. A good way to familiarize 
yourself with bsh is to take a look at those commands - simply unpack 
bsh/commands/*.bsh from the JAR file. 
<P>
<HR>

<H1>Credit and Acknowledgments</H1>Many people have contributed substantially to 
BeanShell, including many who have contributed ideas, which can be just as 
important as code. 
<P>I will try to start listing as many as possible here, but I will forget, so 
please feel free to remind me (don't be modest, everyone who contributes 
deserves to be mentioned). 
<P>
<H4>New Code and Utilities</H4>
<H4>Bug Fixes</H4>
<H4>Me</H4>Finally, I will put in a plug for myself. 
<P><A href="http://www.beanshell.org/mailto:pat@pat.net">Pat Niemeyer</A> 
(pat@pat.net) 
<P><IMG align=left src="BeanShell User's Manual-filer/ej.gif"> If you like 
BeanShell check out my book: <A 
href="http://www.ora.com/catalog/expjava2/">Exploring Java, O'Reilly &amp; 
Associates, 2nd edition</A>. Third edition coming soon! <BR clear=left>
<P></P></BODY></HTML>
